<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-09-27 Sun 13:15 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Panda Paralleli</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Andrew" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>

<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css" integrity="sha384-5sAR7xN1Nv6T6+dT2mhtzEpVJvfS3NScPQTrOxhwjIuvcA67KV2R5Jz6kr4abQsz" crossorigin="anonymous"> 
<link rel="stylesheet" href="css/mystyle.css" type="text/css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<a id ="home" href = "index.html" >
<i class="fa fa-language"></i> </a> <a id ="archive" href = "archive.html" ><i class="fa fa-archive"></i>
 </a> <a id ="archive" href = "about.html" >
<i class="fa fa-address-book"></i></a><a id ="git" href = "https://github.com/andcarnivorous" >
<i class="fab fa-github"></i> </a> <a id ="rss" href = "feed.xml" ><i class="fa fa-rss"></i> 
<font color="black"></font></a><a id ="git" href = "contribute.html" ><i class="fa fa-donate"></i></a>
</div>
<div id="content">
<h1 class="title">Panda Paralleli</h1>


<div id="outline-container-orgd00b2bc" class="outline-2">
<h2 id="orgd00b2bc">Rendere le operazioni in  Pandas più veloci con multiprocessing</h2>
<div class="outline-text-2" id="text-orgd00b2bc">
<p>
aQuante volte sarà capitato di avere un nuovo dataset sotto le mani, appena scaricato o appena finito di mettere insieme con dati presi dal web, e voler subito provare qualche funzione sul dataframe per pulirlo, filtrarlo o aggiungere flags e fare df.apply() e&#x2026;
</p>

<p>
<center><iframe src='https://gfycat.com/ifr/CleverBlaringDutchshepherddog' frameborder='0' scrolling='no' allowfullscreen width='320' height='342'></iframe><p><a href="https://gfycat.com/cleverblaringdutchshepherddog-waiting-taking-forever-time-passing"></a></p></center>
</p>

<p>
Ecco, arrivato ad avere questa esperienza troppe volte mi sono detto: forse dovrei iniziare a vedere come si fa multiprocessing in python e se si può fare in pandas, perchè davvero non posso aspettare 2 minuti solo per fare operazioni fra due serie o due dataframes.
</p>

<p>
La prima cosa che ho trovato sono stati tanti, e tanti, ma tanti tutorial sul multiprocessing e su come usare il package <b>multiprocessing</b> di Python. Stavo quasi per iniziare ad usare quello, quando ho scoperto che per molte delle cose che faccio posso semplicemente usare tre righe dal modulo <b>concurrent.futures</b> e ottenere lo stesso risultato che si ottiene in 4 con <b>multiprocessing</b> in 3. Entrambi sono moduli inclusi in Python3.
Provato e implementato <i>concurrent.futures</i> per task che sono fuori dalla manipolazione dei dataframes, ho deciso di vedere come poter avere risultati simili con questi ultimi e mi sono imbattuto nella libreria <b>pandarallel</b> che si può <a href="https://github.com/nalepae/pandarallel">trovare qui</a>.
Ho applicato pandarallel ad un df.apply() che mi richiedeva circa mezz'ora per completare ed il risultato è stato come mettere una nuova marcia che non c'era nella macchina e vedere il tempo attorno alla Fiat Panda del 90' dilatarsi fino a fermarsi.
</p>

<p>
<center><iframe src='https://gfycat.com/ifr/AcclaimedDentalAnaconda' frameborder='0' scrolling='no' allowfullscreen width='320' height='267'></iframe><p> <a href="https://gfycat.com/acclaimeddentalanaconda"></a></p></center>
</p>
</div>
</div>

<div id="outline-container-org9bfcd4d" class="outline-2">
<h2 id="org9bfcd4d">Gestire operazioni con concurrent.futures</h2>
<div class="outline-text-2" id="text-org9bfcd4d">
<p>
Sto lavorando con un dataset di testi di canzoni, al momento ho circa 10k di testi in un dataframe che riporta anche autore e genere. Ho crawlato e scaricato con degli script tutti questi dati e, dato che sono singoli file, devo creare un unico dataframe dalle directories e file che ho nel sistema. Per far ciò ho una funzione che, però, deve essere eseguita per ogni directory (ce ne sono 4) dove prenderà i file e creerà il dataframe per quel genere musicale.
</p>

<p>
Nelle righe seguenti potete vedere cosa stavo facendo:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> pandas <span style="color: #0000FF;">as</span> pd
<span style="color: #0000FF;">import</span> os
<span style="color: #0000FF;">import</span> pickle <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">to open some dataframes that contain numpy arrays</span>
<span style="color: #0000FF;">import</span> time 
<span style="color: #0000FF;">import</span> concurrent.futures
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> nltk.corpus <span style="color: #0000FF;">import</span> stopwords
<span style="color: #0000FF;">from</span> nltk.tokenize <span style="color: #0000FF;">import</span> word_tokenize
<span style="color: #0000FF;">from</span> pandarallel <span style="color: #0000FF;">import</span> pandarallel 

<span style="color: #BA36A5;">home_dir</span> = os.environ<span style="color: #707183;">[</span><span style="color: #008000;">"HOME"</span><span style="color: #707183;">]</span>

<span style="color: #BA36A5;">genres</span> = <span style="color: #707183;">[</span><span style="color: #008000;">"pop"</span>, <span style="color: #008000;">"rap"</span>, <span style="color: #008000;">"country"</span>, <span style="color: #008000;">"metal"</span><span style="color: #707183;">]</span> <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">these are also the names of the directories</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">make_df</span><span style="color: #707183;">(</span>genre<span style="color: #707183;">)</span>:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span> = pd.DataFrame<span style="color: #707183;">(</span>columns=<span style="color: #7388D6;">[</span><span style="color: #008000;">"author"</span>, <span style="color: #008000;">"genre"</span>, <span style="color: #008000;">"lyrics"</span><span style="color: #7388D6;">]</span><span style="color: #707183;">)</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">counter</span> = 0
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> _f <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">list</span><span style="color: #707183;">(</span><span style="color: #006FE0;">set</span><span style="color: #7388D6;">(</span>os.listdir<span style="color: #909183;">(</span>f<span style="color: #008000;">"{home_dir}/Documents/{genre}/"</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>:
        <span style="color: #0000FF;">if</span> _f.endswith<span style="color: #707183;">(</span><span style="color: #008000;">"MetroLyrics"</span><span style="color: #707183;">)</span> <span style="color: #0000FF;">and</span> <span style="color: #0000FF;">not</span> _f.startswith<span style="color: #707183;">(</span><span style="color: #008000;">"Lyrs"</span><span style="color: #707183;">)</span>:
            <span style="color: #BA36A5;">author</span> = _f.split<span style="color: #707183;">(</span><span style="color: #008000;">"1"</span><span style="color: #707183;">)[</span>0<span style="color: #707183;">][</span>:-1<span style="color: #707183;">]</span>
            <span style="color: #0000FF;">with</span> <span style="color: #006FE0;">open</span><span style="color: #707183;">(</span>f<span style="color: #008000;">"{home_dir}/Documents/{genre}/{_f}"</span><span style="color: #707183;">)</span> <span style="color: #0000FF;">as</span> song:
                <span style="color: #BA36A5;">song</span> = song.read<span style="color: #707183;">()</span>
                <span style="color: #0000FF;">if</span> <span style="color: #006FE0;">len</span><span style="color: #707183;">(</span>song<span style="color: #707183;">)</span> &gt; 20:
                    <span style="color: #BA36A5;">df.loc</span><span style="color: #707183;">[</span>counter<span style="color: #707183;">]</span> = <span style="color: #707183;">[</span>author, genre, song<span style="color: #707183;">]</span>
                    <span style="color: #BA36A5;">counter</span> += 1
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> df


</pre>
</div>

<p>
Questa funzione che crea il dataframe per ogni genere ci impiega un pò troppo ad essere eseguita per ognuno (BEN 67 SECONDI IN TOTALE! Nessuno ha tutto questo tempo.). Usando multiprocessing però, il tempo per la creazione dei dataframes cala notevolmente:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">t0</span> = time.time<span style="color: #707183;">()</span>
<span style="color: #BA36A5;">dfs</span> = <span style="color: #707183;">[</span>make_df<span style="color: #7388D6;">(</span>x<span style="color: #7388D6;">)</span> <span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> genres<span style="color: #707183;">]</span> <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">create dataframe for each genre</span>
<span style="color: #0000FF;">print</span><span style="color: #707183;">(</span><span style="color: #008000;">"DFS:\t"</span>, time.time<span style="color: #7388D6;">()</span>-t0<span style="color: #707183;">)</span>

<span style="color: #BA36A5;">dfs2</span> = <span style="color: #707183;">[]</span>
<span style="color: #BA36A5;">t0</span> = time.time<span style="color: #707183;">()</span>
<span style="color: #0000FF;">with</span> concurrent.futures.ProcessPoolExecutor<span style="color: #707183;">()</span> <span style="color: #0000FF;">as</span> executor:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">dfs2</span> = <span style="color: #707183;">[</span>executor.submit<span style="color: #7388D6;">(</span>make_df, x<span style="color: #7388D6;">)</span> <span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> genres<span style="color: #707183;">]</span> <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">create dataframe for each genre</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">dfs2</span> = <span style="color: #707183;">[</span>f.result<span style="color: #7388D6;">()</span> <span style="color: #0000FF;">for</span> f <span style="color: #0000FF;">in</span> concurrent.futures.as_completed<span style="color: #7388D6;">(</span>dfs2<span style="color: #7388D6;">)</span><span style="color: #707183;">]</span>
<span style="color: #0000FF;">print</span><span style="color: #707183;">(</span><span style="color: #008000;">"DFS Parallel:\t"</span>, time.time<span style="color: #7388D6;">()</span>-t0<span style="color: #707183;">)</span>

</pre>
</div>


<div class="org-src-container">
<pre class="src src-python">DFS:     67.6477198600769
DFS Parallel:    10.724241256713867
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf26b5cb" class="outline-2">
<h2 id="orgf26b5cb">Pandarallel</h2>
<div class="outline-text-2" id="text-orgf26b5cb">
<p>
Ottimo. Adesso però proviamo a fare delle operazioni sul dataframe risultante dalla concatenazione di questi quattro. Per farvi un'idea questo è il <b>df.head()</b> del dataframe che sto utilizzando:
</p>


<div class="figure">
<p><img src="./img/dfhead.png" alt="dfhead.png" />
</p>
</div>

<p>
Quello che ora voglio fare è creare una colonna delle lyrics tokenizzate e con le stopwords rimosse. Per fare ciò userò un <b>df.apply</b> sulla colonna delle lyrics e poi rimuoverò, iterando le celle della colonna, le stopwords dalle liste prodotte (iterare le righe/celle di un pandas dataframe non è sempre la cosa migliore da fare, ma sono pigro ed è la prima cosa a cui ho pensato), misurerò la velocità con cui la tokenizzazione è effettutata usando un <b>apply()</b> normale della libreria pandas e poi usando <b>df.parallel_apply()</b> di pandaralell. Da notare che pandarallel ha bisogno di essere prima inizializzato.
</p>

<div class="org-src-container">
<pre class="src src-python">pandarallel.initialize<span style="color: #707183;">()</span>

<span style="color: #BA36A5;">default_stopwords</span> = <span style="color: #006FE0;">set</span><span style="color: #707183;">(</span>stopwords.words<span style="color: #7388D6;">(</span><span style="color: #008000;">'english'</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

<span style="color: #BA36A5;">custom_stopwords</span> = <span style="color: #707183;">{</span>u<span style="color: #008000;">'http'</span>,u<span style="color: #008000;">'https'</span>,u<span style="color: #008000;">'-'</span>, u<span style="color: #008000;">"get"</span>, u<span style="color: #008000;">"..."</span>, u<span style="color: #008000;">"'"</span>, u<span style="color: #008000;">"'s"</span>, 
                        u<span style="color: #008000;">"n't"</span>, u<span style="color: #008000;">"``"</span>, u<span style="color: #008000;">"''"</span>, u<span style="color: #008000;">"//www"</span>, u<span style="color: #008000;">"'m"</span>, u<span style="color: #008000;">"'re"</span>, <span style="color: #008000;">"would"</span>, 
                        <span style="color: #008000;">"could"</span>, <span style="color: #008000;">"like"</span>, <span style="color: #008000;">"should"</span>, <span style="color: #008000;">"can"</span>, <span style="color: #008000;">"'ve'"</span>, <span style="color: #008000;">"the"</span><span style="color: #707183;">}</span>

<span style="color: #BA36A5;">all_stopwords</span> = default_stopwords | custom_stopwords

<span style="color: #0000FF;">import</span> time

<span style="color: #0000FF;">def</span> <span style="color: #006699;">tokenize_and_remove_stopwords</span><span style="color: #707183;">(</span>df, parallel=<span style="color: #D0372D;">False</span><span style="color: #707183;">)</span>:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> parallel == <span style="color: #D0372D;">True</span>:
        <span style="color: #BA36A5;">t0</span> = time.time<span style="color: #707183;">()</span>
        <span style="color: #BA36A5;">df</span> = df.parallel_apply<span style="color: #707183;">(</span><span style="color: #0000FF;">lambda</span> x: word_tokenize<span style="color: #7388D6;">(</span>x<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
        <span style="color: #0000FF;">print</span><span style="color: #707183;">(</span>f<span style="color: #008000;">"Tokenized in {time.time()-t0}"</span><span style="color: #707183;">)</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">else</span>:
        <span style="color: #BA36A5;">t0</span> = time.time<span style="color: #707183;">()</span>
        <span style="color: #BA36A5;">df</span> = df.<span style="color: #006FE0;">apply</span><span style="color: #707183;">(</span><span style="color: #0000FF;">lambda</span> x: word_tokenize<span style="color: #7388D6;">(</span>x<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
        <span style="color: #0000FF;">print</span><span style="color: #707183;">(</span>f<span style="color: #008000;">"Tokenized with parallel in {time.time()-t0}"</span><span style="color: #707183;">)</span>

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> cell <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span><span style="color: #707183;">(</span><span style="color: #006FE0;">len</span><span style="color: #7388D6;">(</span>df<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>:
        <span style="color: #0000FF;">for</span> word <span style="color: #0000FF;">in</span> df.iloc<span style="color: #707183;">[</span>cell<span style="color: #707183;">]</span>:
            <span style="color: #0000FF;">if</span> word.lower<span style="color: #707183;">()</span> <span style="color: #0000FF;">in</span> all_stopwords:
                df.iloc<span style="color: #707183;">[</span>cell<span style="color: #707183;">]</span>.remove<span style="color: #707183;">(</span>word<span style="color: #707183;">)</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> df


<span style="color: #BA36A5;">tokenized_series</span> = tokenize_and_remove_stopwords<span style="color: #707183;">(</span>lyrics_series<span style="color: #707183;">)</span>
<span style="color: #BA36A5;">tokenized_series</span> = tokenize_and_remove_stopwords<span style="color: #707183;">(</span>lyrics_series, <span style="color: #D0372D;">True</span><span style="color: #707183;">)</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-bash">&gt;INFO: Pandarallel will run on 8 workers.
&gt;INFO: Pandarallel will use Memory file system to transfer data &gt;between the main process and workers.
&gt;Tokenized<span style="color: #0000FF;"> in</span> 21.08686637878418
&gt;Tokenized with parallel<span style="color: #0000FF;"> in</span> 6.702610969543457
</pre>
</div>

<p>
6 secondi invece di 21!
</p>

<p>
Proviamo adesso con un'operazione molto più semplice, rimuovere canzoni dove le lyrics hanno meno di 4 caratteri, cioè dati sbagliati che non voglio nel dataframe.
</p>


<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">t0</span> = time.time<span style="color: #707183;">()</span>
<span style="color: #BA36A5;">lyrics_dataframe</span><span style="color: #707183;">[</span><span style="color: #008000;">"to_delete"</span><span style="color: #707183;">]</span> = lyrics_dataframe.word_list.<span style="color: #006FE0;">apply</span><span style="color: #707183;">(</span><span style="color: #0000FF;">lambda</span> x: <span style="color: #006FE0;">len</span><span style="color: #7388D6;">(</span><span style="color: #006FE0;">set</span><span style="color: #909183;">(</span>x<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span> &lt; 4<span style="color: #707183;">)</span>
<span style="color: #0000FF;">print</span><span style="color: #707183;">(</span><span style="color: #008000;">"Without parallel:\t"</span>, time.time<span style="color: #7388D6;">()</span>-t0<span style="color: #707183;">)</span>
<span style="color: #BA36A5;">lyrics_dataframe</span><span style="color: #707183;">[</span><span style="color: #008000;">"to_delete"</span><span style="color: #707183;">]</span> = lyrics_dataframe.word_list.parallel_apply<span style="color: #707183;">(</span><span style="color: #0000FF;">lambda</span> x: <span style="color: #006FE0;">len</span><span style="color: #7388D6;">(</span><span style="color: #006FE0;">set</span><span style="color: #909183;">(</span>x<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span> &lt; 4<span style="color: #707183;">)</span>
<span style="color: #0000FF;">print</span><span style="color: #707183;">(</span><span style="color: #008000;">"With parallel:\t"</span>, time.time<span style="color: #7388D6;">()</span>-t0<span style="color: #707183;">)</span>

<span style="color: #BA36A5;">lyrics_dataframe</span> = lyrics_dataframe.loc<span style="color: #707183;">[</span>lyrics_dataframe.to_delete == <span style="color: #D0372D;">False</span><span style="color: #707183;">]</span>
lyrics_dataframe.reset_index<span style="color: #707183;">(</span>drop=<span style="color: #D0372D;">True</span>, inplace=<span style="color: #D0372D;">True</span><span style="color: #707183;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">&gt; Without parallel:      0.23779726028442383
&gt; With parallel:         1.634167194366455
</pre>
</div>

<p>
Il processo parallelo è più lento, questo perchè l'operazione è molto semplice ed il guadagno in tempo del parallelismo non è abbastanza da coprire il tempo che ci vuole ad attuare un processo parallelo probabilmente (?).
</p>

<p>
Quindi, usare multiprocessing solo su quantità grandi di dati e quando ci sono operazioni più complesse.
</p>
</div>
</div>

<div id="outline-container-orgf28c1a7" class="outline-2">
<h2 id="orgf28c1a7">Pandarallel su un'operazione lunga:</h2>
<div class="outline-text-2" id="text-orgf28c1a7">
<p>
Per ultima cosa, ho usato pandarallel su un apply che, quando ho usato sul dataframe ad uno stadio più piccolo, già impiegava tra i 20 e 30 minuti per essere completato, adesso lo userò sulla stessa operazione ma con 3 volte il numero di entries nel dataframe. L'operazione consiste nel prendere ogni parola nella colonna <b>word_list</b> e per ognuna di quelle parole trovare il corrispondente word vector (che ho precedentemente creato, cose per un altro articolo) in un altro dataframe dedicato ai word vectors. Presi tutti i word vectors presenti in una canzone, calcolerò il document vector di ogni canzone con la mia tanto incredibile quanto complessa formula:
</p>


<div class="figure">
<p><img src="./img/mean.png" alt="mean.png" />
</p>
</div>



<div class="org-src-container">
<pre class="src src-python">pandarallel.initialize<span style="color: #707183;">(</span>progress_bar=<span style="color: #D0372D;">True</span><span style="color: #707183;">)</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">get_mean_vector</span><span style="color: #707183;">(</span>_input<span style="color: #707183;">)</span>:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">vectors</span> = <span style="color: #707183;">[</span>0<span style="color: #707183;">]</span>*<span style="color: #006FE0;">len</span><span style="color: #707183;">(</span>_input<span style="color: #707183;">)</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> word <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span><span style="color: #707183;">(</span><span style="color: #006FE0;">len</span><span style="color: #7388D6;">(</span>_input<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>:
        <span style="color: #BA36A5;">vectors</span><span style="color: #707183;">[</span>word<span style="color: #707183;">]</span> = dataframe.vector.loc<span style="color: #707183;">[</span>dataframe.word == _input<span style="color: #7388D6;">[</span>word<span style="color: #7388D6;">]</span><span style="color: #707183;">]</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.mean<span style="color: #707183;">(</span>vectors<span style="color: #707183;">)</span>

<span style="color: #BA36A5;">t0</span> = time.time<span style="color: #707183;">()</span>
<span style="color: #BA36A5;">vecs</span> = df.word_list.loc<span style="color: #707183;">[</span>:<span style="color: #006FE0;">int</span><span style="color: #7388D6;">(</span><span style="color: #006FE0;">len</span><span style="color: #909183;">(</span>df<span style="color: #909183;">)</span>/10<span style="color: #7388D6;">)</span><span style="color: #707183;">]</span>.parallel_apply<span style="color: #707183;">(</span>get_mean_vector<span style="color: #707183;">)</span>
<span style="color: #0000FF;">print</span><span style="color: #707183;">(</span><span style="color: #008000;">"Parallel:\t"</span>, time.time<span style="color: #7388D6;">()</span>-t0<span style="color: #707183;">)</span>

<span style="color: #BA36A5;">t0</span> = time.time<span style="color: #707183;">()</span>
<span style="color: #BA36A5;">vecs2</span> = df.word_list.loc<span style="color: #707183;">[</span>:<span style="color: #006FE0;">int</span><span style="color: #7388D6;">(</span><span style="color: #006FE0;">len</span><span style="color: #909183;">(</span>df<span style="color: #909183;">)</span>/10<span style="color: #7388D6;">)</span><span style="color: #707183;">]</span>.<span style="color: #006FE0;">apply</span><span style="color: #707183;">(</span>get_mean_vector<span style="color: #707183;">)</span>
<span style="color: #0000FF;">print</span><span style="color: #707183;">(</span><span style="color: #008000;">"Not Parallel:\t"</span>, time.time<span style="color: #7388D6;">()</span>-t0<span style="color: #707183;">)</span>

</pre>
</div>


<div class="figure">
<p><img src="./img/parallelscore.png" alt="parallelscore.png" />
</p>
</div>

<p>
491 secondi invece di 1706, risparmiato più di 2/3 del tempo, e questo usandolo solo su un decimo del mio dataset, sul dataset intero in parallelo ci vuole quasi un'ora, se usassi il semplice metodo apply di Pandas probabilmente dovrei lasciare il pc acceso la notte.
Ecco una piccola bar chart dei risultati:
</p>


<div class="figure">
<p><img src="./img/parallelbar1.png" alt="parallelbar1.png" />
<img src="./img/parallelbar2.png" alt="parallelbar2.png" />
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div>
<script src="https://utteranc.es/client.js"
        repo="andcarnivorous/andcarnivorous.github.io"
        issue-term="title"
        crossorigin="anonymous"
        async>
</script>
</div>
<p class="date">Date: 2020-09-26 Sat 00:00</p>
<p class="author"> Author: Andrew</p>
<a href = "archive.html" >Other posts</a>
</div>
</body>
</html>
